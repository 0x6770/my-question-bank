-- Add exam_papers table and storage bucket for PDF uploads

-- 1) Table definition
CREATE TABLE IF NOT EXISTS public.exam_papers (
  id                  bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id          bigint NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
  year                smallint NOT NULL CHECK (year BETWEEN 1900 AND 2100),
  season              text NOT NULL CHECK (char_length(season) <= 32),
  paper_code          text NOT NULL,
  paper_label         text NOT NULL,
  time_zone           text,
  question_paper_path text,
  mark_scheme_path    text,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT question_pdf_only CHECK (question_paper_path IS NULL OR question_paper_path ~* '\\.pdf$'),
  CONSTRAINT mark_scheme_pdf_only CHECK (mark_scheme_path IS NULL OR mark_scheme_path ~* '\\.pdf$'),
  CONSTRAINT uq_exam_paper UNIQUE (subject_id, year, season, paper_code)
);

CREATE INDEX IF NOT EXISTS exam_papers_subject_year_idx ON public.exam_papers(subject_id, year, season);
CREATE INDEX IF NOT EXISTS exam_papers_season_idx ON public.exam_papers(season);

ALTER TABLE public.exam_papers ENABLE ROW LEVEL SECURITY;

-- 2) updated_at trigger
CREATE OR REPLACE FUNCTION public.set_exam_papers_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_exam_papers_updated_at ON public.exam_papers;
CREATE TRIGGER set_exam_papers_updated_at
BEFORE UPDATE ON public.exam_papers
FOR EACH ROW
EXECUTE FUNCTION public.set_exam_papers_updated_at();

-- 3) RLS policies (admins manage; users read permitted subjects)
CREATE POLICY "exam_papers.select_allowed_subjects" ON public.exam_papers
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1 FROM public.user_subject_access usa
      WHERE usa.subject_id = exam_papers.subject_id
        AND usa.user_id = auth.uid()
    )
  );

CREATE POLICY "exam_papers.insert_admins" ON public.exam_papers
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "exam_papers.update_admins" ON public.exam_papers
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "exam_papers.delete_admins" ON public.exam_papers
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

GRANT ALL ON TABLE public.exam_papers TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.exam_papers_id_seq TO anon, authenticated, service_role;

-- 4) Storage bucket for PDFs (question + mark scheme)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'exam_papers',
  'exam_papers',
  FALSE,
  104857600,           -- 100MB limit; adjust if needed
  '{"application/pdf"}'::text[]
)
ON CONFLICT (id) DO UPDATE
SET
  public             = EXCLUDED.public,
  file_size_limit    = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- Storage RLS: enforce subject access by matching object name prefix with exam_papers.id
-- Expected storage path convention: <exam_paper_id>/question.pdf or <exam_paper_id>/mark-scheme.pdf
CREATE POLICY "exam_papers_storage_select_allowed" ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'exam_papers'
    AND EXISTS (
      SELECT 1
      FROM public.exam_papers ep
      WHERE ep.id::text = split_part(name, '/', 1)
        AND (
          public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
          OR EXISTS (
            SELECT 1 FROM public.user_subject_access usa
            WHERE usa.subject_id = ep.subject_id
              AND usa.user_id = auth.uid()
          )
        )
    )
  );

CREATE POLICY "exam_papers_storage_insert_admins" ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'exam_papers'
    AND public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
  );

CREATE POLICY "exam_papers_storage_update_admins" ON storage.objects
  FOR UPDATE
  TO authenticated
  USING (
    bucket_id = 'exam_papers'
    AND public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
  )
  WITH CHECK (
    bucket_id = 'exam_papers'
    AND public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
  );

CREATE POLICY "exam_papers_storage_delete_admins" ON storage.objects
  FOR DELETE
  TO authenticated
  USING (
    bucket_id = 'exam_papers'
    AND public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
  );
