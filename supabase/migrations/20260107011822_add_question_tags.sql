-- Add subject-specific question tags system for past paper questions and topical questions
-- This system parallels the exam_papers tag system but applies to individual questions

-- ============================================================================
-- 1) TABLES
-- ============================================================================

-- 1.1) Subject-level question tag definitions
CREATE TABLE IF NOT EXISTS public.subject_question_tags (
  id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id  bigint NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
  name        text NOT NULL,
  required    boolean NOT NULL DEFAULT false,
  position    smallint NOT NULL DEFAULT 0,
  is_system   boolean NOT NULL DEFAULT false,  -- System tags (like "paper") cannot be deleted
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT subject_question_tags_unique_name UNIQUE (subject_id, name),
  CONSTRAINT subject_question_tags_name_length CHECK (char_length(name) BETWEEN 1 AND 50)
);

CREATE INDEX IF NOT EXISTS subject_question_tags_subject_idx
  ON public.subject_question_tags(subject_id, position, name);

COMMENT ON TABLE public.subject_question_tags IS
  'Tag definitions for questions, specific to each subject. System tags like "paper" are auto-created and protected.';
COMMENT ON COLUMN public.subject_question_tags.is_system IS
  'System tags (e.g., "paper") cannot be deleted or renamed. They are auto-created for all subjects.';


-- 1.2) Allowed values per question tag
CREATE TABLE IF NOT EXISTS public.subject_question_tag_values (
  id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag_id      bigint NOT NULL REFERENCES public.subject_question_tags(id) ON DELETE CASCADE,
  value       text NOT NULL,
  position    smallint NOT NULL DEFAULT 0,
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT subject_question_tag_values_unique UNIQUE (tag_id, value),
  CONSTRAINT subject_question_tag_values_value_length CHECK (char_length(value) BETWEEN 1 AND 100)
);

CREATE INDEX IF NOT EXISTS subject_question_tag_values_tag_idx
  ON public.subject_question_tag_values(tag_id, position, value);

COMMENT ON TABLE public.subject_question_tag_values IS
  'Allowed values for each question tag. E.g., tag "paper" might have values P1, P2, P3.';


-- 1.3) Mapping question -> tag values + subject_id for multi-subject support
CREATE TABLE IF NOT EXISTS public.question_tag_values (
  question_id  bigint NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
  tag_value_id bigint NOT NULL REFERENCES public.subject_question_tag_values(id) ON DELETE CASCADE,
  subject_id   bigint NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
  created_at   timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT question_tag_values_pk PRIMARY KEY (question_id, tag_value_id, subject_id)
);

-- Index for querying all tags for a question+subject combination
CREATE INDEX IF NOT EXISTS question_tag_values_question_subject_idx
  ON public.question_tag_values(question_id, subject_id);

-- Index for reverse lookup: find questions by tag value
CREATE INDEX IF NOT EXISTS question_tag_values_tag_value_idx
  ON public.question_tag_values(tag_value_id);

COMMENT ON TABLE public.question_tag_values IS
  'Links questions to tag values. subject_id enables one question to have different tag sets per subject.';
COMMENT ON COLUMN public.question_tag_values.subject_id IS
  'Identifies which subject this tag association belongs to, enabling cross-subject questions with independent tag values.';


-- ============================================================================
-- 2) TRIGGERS
-- ============================================================================

-- 2.1) Auto-create "paper" tag for new subjects
CREATE OR REPLACE FUNCTION public.ensure_paper_tag_for_subject()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO public.subject_question_tags (subject_id, name, required, position, is_system)
  VALUES (NEW.id, 'paper', true, 0, true)
  ON CONFLICT (subject_id, name) DO NOTHING;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS ensure_paper_tag_for_subject ON public.subjects;
CREATE TRIGGER ensure_paper_tag_for_subject
AFTER INSERT ON public.subjects
FOR EACH ROW EXECUTE FUNCTION public.ensure_paper_tag_for_subject();

COMMENT ON FUNCTION public.ensure_paper_tag_for_subject IS
  'Automatically creates the required "paper" system tag when a new subject is created.';


-- 2.2) Backfill "paper" tag for existing subjects
INSERT INTO public.subject_question_tags (subject_id, name, required, position, is_system)
SELECT s.id, 'paper', true, 0, true
FROM public.subjects s
ON CONFLICT (subject_id, name) DO NOTHING;


-- 2.3) Prevent deletion of system tags
CREATE OR REPLACE FUNCTION public.prevent_system_tag_deletion()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF OLD.is_system THEN
    RAISE EXCEPTION 'Cannot delete system tag "%". This tag is required for all questions.', OLD.name;
  END IF;
  RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS prevent_system_tag_deletion ON public.subject_question_tags;
CREATE TRIGGER prevent_system_tag_deletion
BEFORE DELETE ON public.subject_question_tags
FOR EACH ROW EXECUTE FUNCTION public.prevent_system_tag_deletion();


-- 2.4) Prevent renaming of system tags
CREATE OR REPLACE FUNCTION public.prevent_system_tag_rename()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF OLD.is_system AND OLD.name <> NEW.name THEN
    RAISE EXCEPTION 'Cannot rename system tag "%" to "%". System tags are protected.', OLD.name, NEW.name;
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS prevent_system_tag_rename ON public.subject_question_tags;
CREATE TRIGGER prevent_system_tag_rename
BEFORE UPDATE ON public.subject_question_tags
FOR EACH ROW EXECUTE FUNCTION public.prevent_system_tag_rename();


-- 2.5) Validate that tag_value belongs to the correct subject
CREATE OR REPLACE FUNCTION public.check_question_tag_value_subject()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  value_subject_id bigint;
BEGIN
  -- Get the subject_id that this tag_value actually belongs to
  SELECT t.subject_id INTO value_subject_id
  FROM public.subject_question_tag_values v
  JOIN public.subject_question_tags t ON t.id = v.tag_id
  WHERE v.id = NEW.tag_value_id;

  IF value_subject_id IS NULL THEN
    RAISE EXCEPTION 'tag_value_id % does not exist', NEW.tag_value_id;
  END IF;

  -- Ensure it matches the subject_id specified in the question_tag_values row
  IF value_subject_id <> NEW.subject_id THEN
    RAISE EXCEPTION 'Tag value (id=%) belongs to subject %, not subject %. Cannot assign tag value across subjects.',
      NEW.tag_value_id, value_subject_id, NEW.subject_id;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS ensure_question_tag_value_subject ON public.question_tag_values;
CREATE TRIGGER ensure_question_tag_value_subject
BEFORE INSERT OR UPDATE ON public.question_tag_values
FOR EACH ROW EXECUTE FUNCTION public.check_question_tag_value_subject();

COMMENT ON FUNCTION public.check_question_tag_value_subject IS
  'Ensures tag values are only assigned to questions for the correct subject, preventing cross-subject tag pollution.';


-- 2.6) Auto-update updated_at timestamps
CREATE OR REPLACE FUNCTION public.set_question_tags_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_subject_question_tags_updated_at ON public.subject_question_tags;
CREATE TRIGGER set_subject_question_tags_updated_at
BEFORE UPDATE ON public.subject_question_tags
FOR EACH ROW EXECUTE FUNCTION public.set_question_tags_updated_at();

DROP TRIGGER IF EXISTS set_subject_question_tag_values_updated_at ON public.subject_question_tag_values;
CREATE TRIGGER set_subject_question_tag_values_updated_at
BEFORE UPDATE ON public.subject_question_tag_values
FOR EACH ROW EXECUTE FUNCTION public.set_question_tags_updated_at();


-- ============================================================================
-- 3) ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

ALTER TABLE public.subject_question_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subject_question_tag_values ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.question_tag_values ENABLE ROW LEVEL SECURITY;

-- subject_question_tags policies
CREATE POLICY "subject_question_tags.select_allowed" ON public.subject_question_tags
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1 FROM public.user_subject_access usa
      WHERE usa.subject_id = subject_question_tags.subject_id
        AND usa.user_id = auth.uid()
    )
  );

CREATE POLICY "subject_question_tags.insert_admins" ON public.subject_question_tags
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_question_tags.update_admins" ON public.subject_question_tags
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_question_tags.delete_admins" ON public.subject_question_tags
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

-- subject_question_tag_values policies
CREATE POLICY "subject_question_tag_values.select_allowed" ON public.subject_question_tag_values
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1
      FROM public.subject_question_tags t
      JOIN public.user_subject_access usa ON usa.subject_id = t.subject_id AND usa.user_id = auth.uid()
      WHERE t.id = subject_question_tag_values.tag_id
    )
  );

CREATE POLICY "subject_question_tag_values.insert_admins" ON public.subject_question_tag_values
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_question_tag_values.update_admins" ON public.subject_question_tag_values
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_question_tag_values.delete_admins" ON public.subject_question_tag_values
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

-- question_tag_values policies
CREATE POLICY "question_tag_values.select_allowed" ON public.question_tag_values
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1 FROM public.user_subject_access usa
      WHERE usa.subject_id = question_tag_values.subject_id
        AND usa.user_id = auth.uid()
    )
  );

CREATE POLICY "question_tag_values.insert_admins" ON public.question_tag_values
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "question_tag_values.update_admins" ON public.question_tag_values
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "question_tag_values.delete_admins" ON public.question_tag_values
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));


-- ============================================================================
-- 4) GRANTS
-- ============================================================================

GRANT ALL ON TABLE public.subject_question_tags TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.subject_question_tags_id_seq TO anon, authenticated, service_role;

GRANT ALL ON TABLE public.subject_question_tag_values TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.subject_question_tag_values_id_seq TO anon, authenticated, service_role;

GRANT ALL ON TABLE public.question_tag_values TO anon, authenticated, service_role;


-- ============================================================================
-- 5) RPC FUNCTIONS FOR TAG MANAGEMENT
-- ============================================================================

-- 5.1) Update tags for a single subject
CREATE OR REPLACE FUNCTION public.update_question_tags_for_subject(
  p_question_id bigint,
  p_subject_id bigint,
  p_tag_value_ids bigint[]
) RETURNS void
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_tag_count integer;
BEGIN
  -- Validate question exists
  IF NOT EXISTS (SELECT 1 FROM questions WHERE id = p_question_id) THEN
    RAISE EXCEPTION 'Question % does not exist', p_question_id;
  END IF;

  -- Validate subject exists
  IF NOT EXISTS (SELECT 1 FROM subjects WHERE id = p_subject_id) THEN
    RAISE EXCEPTION 'Subject % does not exist', p_subject_id;
  END IF;

  v_tag_count := coalesce(array_length(p_tag_value_ids, 1), 0);

  -- Delete old tag associations for this question + subject
  DELETE FROM question_tag_values
  WHERE question_id = p_question_id
    AND subject_id = p_subject_id;

  -- Insert new tag associations (trigger will validate tag_value belongs to subject)
  IF v_tag_count > 0 THEN
    INSERT INTO question_tag_values (question_id, tag_value_id, subject_id)
    SELECT p_question_id, unnest(p_tag_value_ids), p_subject_id;
  END IF;
END;
$$;

COMMENT ON FUNCTION public.update_question_tags_for_subject IS
  'Updates all tag values for a question within a specific subject. Atomic operation: deletes old tags, inserts new ones.';


-- 5.2) Update tags for multiple subjects at once
CREATE OR REPLACE FUNCTION public.update_question_tags(
  p_question_id bigint,
  p_tags jsonb  -- Format: [{"subject_id": 1, "tag_value_ids": [101,102]}, {"subject_id": 2, "tag_value_ids": [203]}]
) RETURNS void
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_tag_entry jsonb;
  v_subject_id bigint;
  v_tag_value_ids bigint[];
BEGIN
  -- Validate question exists
  IF NOT EXISTS (SELECT 1 FROM questions WHERE id = p_question_id) THEN
    RAISE EXCEPTION 'Question % does not exist', p_question_id;
  END IF;

  -- Delete all existing tag associations for this question
  DELETE FROM question_tag_values WHERE question_id = p_question_id;

  -- Iterate through each subject's tag configuration
  FOR v_tag_entry IN SELECT * FROM jsonb_array_elements(p_tags)
  LOOP
    v_subject_id := (v_tag_entry->>'subject_id')::bigint;
    v_tag_value_ids := ARRAY(
      SELECT jsonb_array_elements_text(v_tag_entry->'tag_value_ids')::bigint
    );

    IF array_length(v_tag_value_ids, 1) > 0 THEN
      INSERT INTO question_tag_values (question_id, tag_value_id, subject_id)
      SELECT p_question_id, unnest(v_tag_value_ids), v_subject_id;
    END IF;
  END LOOP;
END;
$$;

COMMENT ON FUNCTION public.update_question_tags IS
  'Updates tags for a question across multiple subjects. Accepts JSON array with subject_id and tag_value_ids. Atomic operation.';


-- 5.3) Create question with chapters AND tags
CREATE OR REPLACE FUNCTION public.create_question_with_chapters_and_tags(
  p_marks smallint,
  p_difficulty smallint,
  p_calculator boolean,
  p_chapter_ids bigint[],
  p_tags jsonb  -- Format same as update_question_tags
) RETURNS bigint
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
  v_question_id bigint;
BEGIN
  -- Use existing function to create question and associate chapters
  v_question_id := create_question_with_chapters(
    p_marks,
    p_difficulty,
    p_calculator,
    p_chapter_ids
  );

  -- Set tags if provided
  IF p_tags IS NOT NULL AND jsonb_array_length(p_tags) > 0 THEN
    PERFORM update_question_tags(v_question_id, p_tags);
  END IF;

  RETURN v_question_id;
END;
$$;

COMMENT ON FUNCTION public.create_question_with_chapters_and_tags IS
  'Creates a question with chapters and tags in a single transaction. Extends create_question_with_chapters to support tags.';
