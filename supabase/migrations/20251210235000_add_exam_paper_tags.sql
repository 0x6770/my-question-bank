-- Add subject-specific exam paper tags and tag values, and link exam papers to tag values.

-- 1) Subject-level tag definitions
CREATE TABLE IF NOT EXISTS public.subject_exam_tags (
  id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id  bigint NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
  name        text NOT NULL,
  required    boolean NOT NULL DEFAULT false,
  position    smallint NOT NULL DEFAULT 0,
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT subject_exam_tags_unique_name UNIQUE (subject_id, name)
);

CREATE INDEX IF NOT EXISTS subject_exam_tags_subject_idx
  ON public.subject_exam_tags(subject_id, position, name);

-- 2) Allowed values per tag
CREATE TABLE IF NOT EXISTS public.subject_exam_tag_values (
  id          bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag_id      bigint NOT NULL REFERENCES public.subject_exam_tags(id) ON DELETE CASCADE,
  value       text NOT NULL,
  position    smallint NOT NULL DEFAULT 0,
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT subject_exam_tag_values_unique UNIQUE (tag_id, value)
);

CREATE INDEX IF NOT EXISTS subject_exam_tag_values_tag_idx
  ON public.subject_exam_tag_values(tag_id, position, value);

-- 3) Mapping exam paper -> chosen tag values
CREATE TABLE IF NOT EXISTS public.exam_paper_tag_values (
  exam_paper_id bigint NOT NULL REFERENCES public.exam_papers(id) ON DELETE CASCADE,
  tag_value_id  bigint NOT NULL REFERENCES public.subject_exam_tag_values(id) ON DELETE CASCADE,
  created_at    timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT exam_paper_tag_values_pk PRIMARY KEY (exam_paper_id, tag_value_id)
);

-- 4) updated_at triggers
CREATE OR REPLACE FUNCTION public.set_subject_exam_tags_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_subject_exam_tags_updated_at ON public.subject_exam_tags;
CREATE TRIGGER set_subject_exam_tags_updated_at
BEFORE UPDATE ON public.subject_exam_tags
FOR EACH ROW EXECUTE FUNCTION public.set_subject_exam_tags_updated_at();

CREATE OR REPLACE FUNCTION public.set_subject_exam_tag_values_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_subject_exam_tag_values_updated_at ON public.subject_exam_tag_values;
CREATE TRIGGER set_subject_exam_tag_values_updated_at
BEFORE UPDATE ON public.subject_exam_tag_values
FOR EACH ROW EXECUTE FUNCTION public.set_subject_exam_tag_values_updated_at();

-- 5) Guard: ensure tag value subject matches exam paper subject
CREATE OR REPLACE FUNCTION public.check_exam_paper_tag_value_subject()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  paper_subject_id bigint;
  value_subject_id bigint;
BEGIN
  SELECT subject_id INTO paper_subject_id FROM public.exam_papers WHERE id = NEW.exam_paper_id;
  IF paper_subject_id IS NULL THEN
    RAISE EXCEPTION 'exam_paper_id % not found', NEW.exam_paper_id;
  END IF;

  SELECT t.subject_id
  INTO value_subject_id
  FROM public.subject_exam_tag_values v
  JOIN public.subject_exam_tags t ON t.id = v.tag_id
  WHERE v.id = NEW.tag_value_id;

  IF value_subject_id IS NULL THEN
    RAISE EXCEPTION 'tag_value_id % not found', NEW.tag_value_id;
  END IF;

  IF value_subject_id <> paper_subject_id THEN
    RAISE EXCEPTION 'Tag value subject % does not match exam paper subject %', value_subject_id, paper_subject_id;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS ensure_exam_paper_tag_value_subject ON public.exam_paper_tag_values;
CREATE TRIGGER ensure_exam_paper_tag_value_subject
BEFORE INSERT OR UPDATE ON public.exam_paper_tag_values
FOR EACH ROW EXECUTE FUNCTION public.check_exam_paper_tag_value_subject();

-- 6) RLS
ALTER TABLE public.subject_exam_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subject_exam_tag_values ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exam_paper_tag_values ENABLE ROW LEVEL SECURITY;

-- subject_exam_tags policies
CREATE POLICY "subject_exam_tags.select_allowed" ON public.subject_exam_tags
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1 FROM public.user_subject_access usa
      WHERE usa.subject_id = subject_exam_tags.subject_id
        AND usa.user_id = auth.uid()
    )
  );

CREATE POLICY "subject_exam_tags.insert_admins" ON public.subject_exam_tags
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_exam_tags.update_admins" ON public.subject_exam_tags
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_exam_tags.delete_admins" ON public.subject_exam_tags
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

-- subject_exam_tag_values policies
CREATE POLICY "subject_exam_tag_values.select_allowed" ON public.subject_exam_tag_values
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1
      FROM public.subject_exam_tags t
      JOIN public.user_subject_access usa ON usa.subject_id = t.subject_id AND usa.user_id = auth.uid()
      WHERE t.id = subject_exam_tag_values.tag_id
    )
  );

CREATE POLICY "subject_exam_tag_values.insert_admins" ON public.subject_exam_tag_values
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_exam_tag_values.update_admins" ON public.subject_exam_tag_values
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "subject_exam_tag_values.delete_admins" ON public.subject_exam_tag_values
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

-- exam_paper_tag_values policies
CREATE POLICY "exam_paper_tag_values.select_allowed" ON public.exam_paper_tag_values
  FOR SELECT
  USING (
    public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role])
    OR EXISTS (
      SELECT 1
      FROM public.exam_papers ep
      JOIN public.user_subject_access usa ON usa.subject_id = ep.subject_id AND usa.user_id = auth.uid()
      WHERE ep.id = exam_paper_tag_values.exam_paper_id
    )
  );

CREATE POLICY "exam_paper_tag_values.insert_admins" ON public.exam_paper_tag_values
  FOR INSERT
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "exam_paper_tag_values.update_admins" ON public.exam_paper_tag_values
  FOR UPDATE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]))
  WITH CHECK (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

CREATE POLICY "exam_paper_tag_values.delete_admins" ON public.exam_paper_tag_values
  FOR DELETE
  USING (public.in_roles(VARIADIC ARRAY['admin'::public.user_role, 'super_admin'::public.user_role]));

-- 7) Grants
GRANT ALL ON TABLE public.subject_exam_tags TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.subject_exam_tags_id_seq TO anon, authenticated, service_role;

GRANT ALL ON TABLE public.subject_exam_tag_values TO anon, authenticated, service_role;
GRANT ALL ON SEQUENCE public.subject_exam_tag_values_id_seq TO anon, authenticated, service_role;

GRANT ALL ON TABLE public.exam_paper_tag_values TO anon, authenticated, service_role;
